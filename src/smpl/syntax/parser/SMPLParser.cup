package smpl.syntax.parser;

import java_cup.runtime.*;
import java.io.*;
import java.util.*;

import smpl.exceptions.SMPLSyntaxException;

import smpl.syntax.lexer.SMPLLexer;

import smpl.syntax.ast.core.Exp;
import smpl.syntax.ast.core.SMPLProgram;
import smpl.syntax.ast.*;

import smpl.types.SMPLValue;

/* Preliminaries to set up and use the scanner.  */
parser code {:
		SMPLLexer lexer;

		public SMPLParser(SMPLLexer l) {
		    // As of CUP v0.11, need to pass Lexer to superclass
		    super(l);
		    lexer = l;
		}

		public void report_error(String message, Object info) {
		    System.err.println(message);
		}

		public void syntax_error(Symbol cur_token) {
		    System.err.println("Line " + lexer.getLine());

            int column = lexer.getColumn();

            for (int i = 0; i < column; i++) {
                System.err.print(lexer.yycharat(i));
            }
            System.err.println();

            // print an indicator on screen that will show the user
            // where the error is
            String indicator = String.format("%" + lexer.getColumn() + "s","^");
            System.err.println(indicator);

		    report_error("Syntax error", cur_token);
		}
	    :};

init with {:
	  :};

scan with {:
		try {
		    return lexer.next_token();
		} catch (java.io.IOException ioe) {
		    String msg = "Line " + lexer.getLine() + ", pos " +
				       lexer.getColumn() +
				       ": Unrecognised token <" +
                       lexer.getText() + ">";
		    throw new SMPLSyntaxException(msg, ioe);
		}
	  :};

/* Terminals (tokens returned by the scanner). */

// special symbols
terminal LPAREN, RPAREN, SEMI;

// arithmetic operators
terminal PLUS, MINUS, MUL, DIV, MOD, ASSIGN, POW;

// terminals with values
terminal String ID;
terminal Integer INT;
terminal Double DOUBLE;
terminal String STRING;
terminal Boolean BOOLEAN;

/* Non terminals */
non terminal SMPLProgram program;
non terminal StmtSequence stmtList;
non terminal Statement stmt;
non terminal StmtDefinition definition;
non terminal Exp expression;
non terminal Exp arithExp;
non terminal Exp term;
non terminal Exp factor;
non terminal Exp unary;
non terminal Exp primary;
non terminal SMPLValue<?> literal;
non terminal empty;

/* Grammar rules */

program ::= stmtList:s {: RESULT = new SMPLProgram(s); :};

stmtList ::= stmtList:lst stmt:s {:
                lst.add(s); 
                RESULT = lst;
		     :} |
	         stmt:s {:
		        RESULT = new StmtSequence(s);
		     :};

stmt ::= definition:d {: RESULT = d; :} |
	     expression:e SEMI {: RESULT = new Statement(e); :};

definition ::= ID:id ASSIGN expression:e SEMI {:
		            RESULT = new StmtDefinition(id, e); :};

expression ::= arithExp:a {: RESULT = a; :};

arithExp ::= arithExp:e PLUS term:t {:
                RESULT = new ExpAdd(e, t); :} |
             arithExp:e MINUS term:t {:
                RESULT = new ExpSub(e, t); :} |
		     term:t {: RESULT = t; :};

term ::= term:t MUL factor:f {:
		    RESULT = new ExpMul(t, f); :} |
	     term:t DIV factor:f {:
		    RESULT = new ExpDiv(t, f); :} |
	     term:t MOD factor:f {:
		    RESULT = new ExpMod(t, f); :} |
	     factor:f {: RESULT = f; :};

factor ::= unary:u POW factor:f {:
            RESULT = new ExpPow(u, f); :} |
           unary:u {: RESULT = u; :};

unary ::= PLUS unary:u {: RESULT = new ExpUnary("+", u); :} |
          MINUS unary:u {: RESULT = new ExpUnary("-", u); :} |
          primary:p {: RESULT = p; :};

primary ::= literal:lit {: RESULT = new ExpLit(lit); :} |
	        ID:id {: RESULT = new ExpId(id); :} |
	        LPAREN expression:e RPAREN {: RESULT = e; :};

literal ::= INT:ilit {: RESULT = SMPLValue.make(ilit); :} |
            DOUBLE:dlit {: RESULT = SMPLValue.make(dlit); :} |
            STRING:slit {: RESULT = SMPLValue.make(slit); :} |
            BOOLEAN:blit {: RESULT = SMPLValue.make(blit); :};

empty ::= ;
